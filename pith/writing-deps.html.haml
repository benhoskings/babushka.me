---
layout: "/_layout.html.haml"
title: Writing deps
---

:md
  It's all very well to run `babushka blah` and have it do jobs for you, but the real power is in babushka's ability to automate whatever chore you want, not just ones that others have thought of already.


  ## Context (or lack of it)

  When you're writing a dep, you don't have to think about context at all, just one little task in isolation. As long as your `requires` are correct, you can leave the overall structure to babushka and just write each little dep separately.

  When you invoke the dep, babushka uses the `requires` in each dep to assemble a tree of deps and achieve the end goal you're after.

  The other reason to ignore context when writing each dep is that context is coupling. Keeping deps decoupled means they can be more easily re-used in different situations, where the context is probably different.


  ## Writing `met?` and `meet`

  The section on [how deps work](/dep-sources) explains the structure of a dep. To see how each section works, let's build a simple dep to symlink a directory. _Code on the left, shell output on the right._

:precaptionedruby
  dep 'work symlinked'

  $ babushka 'work symlinked'
  work symlinked {
  } ✓ work symlinked
  $


:md
  That's the simplest dep there is: you don't need to supply a dep block if you have nothing to put in it. Since the `met?` and `meet` blocks both default to being empty, though, it's not very useful.

  _An empty `met?` block defaults to true (so that deps that do nothing but require other deps act as passthroughs)._

  Let's add a `met?` block with a simple check.

:precaptionedruby
  dep 'work symlinked' do
    met? {
      # The String#p patch expands the string and returns
      # a Fancypath, which has lots of useful helpers.
      "~/work".p.exists?
    }
  end

  $ babushka 'work symlinked'
  work symlinked {
    meet {
    }
  } ✗ work symlinked
  $

:md
  This time, the logic we put in the `met?` block returned false (because `~/work` didn't exist). To see when that block is being run, let's add some logging:

:precaptionedruby
  dep 'work symlinked' do
    met? {
      "~/work".p.exists?.tap {|result|
        log "met?: \#{result}."
      }
    }
  end

  $ babushka 'work symlinked'
  work symlinked {
    met?: false.
    meet {
    }
    met?: false.
  } ✗ work symlinked
  $

:md
  This shows that babushka is running the `met?` block twice: first to check, and then again after running `meet` (which is empty in this case). This is where `meet` comes in: it's a piece of logic that, when run, should make `met?` return true.

  Let's fill in the `meet` block to complete the dep.

:precaptionedruby
  dep 'work symlinked' do
    met? {
      "~/work".p.exists?.tap {|result|
        log "met?: \#{result}."
      }
    }
    meet {
      shell "ln -s ~/jobs/acme ~/work"
      log "made the symlink."
    }
  end

  $ babushka 'work symlinked'
  work symlinked {
    met?: false.
    meet {
      made the symlink.
    }
    met?: true.
  } ✓ work symlinked
  $

:md
  This is how deps work (detailed [here](/how-deps-work)): it's the work `meet` did on the system, not its return value, that matters. Once `meet` runs, the `met?` check is passing, and we're done. Without the logging, the final version of our dep looks like this:

:precaptionedruby
  dep 'work symlinked' do
    met? {
      "~/work".p.exists?
    }
    meet {
      shell "ln -s ~/jobs/acme ~/work"
    }
  end

  $ babushka 'work symlinked'
  work symlinked {
    meet {
    }
  } ✓ work symlinked
  $

:md
  Note the clean split between met? and meet: `met?` checks, and `meet` acts. If you find you're checking for the presence of some condition in your `meet` block, it probably means you're trying to do too much in a single dep, and you should be splitting it up into smaller ones. Remember, deps are small, self-contained and context-free - the more focused, the better.


  ## Requirements

  TODO

  ## Dep parameters

  TODO

  ## Templated Deps

  The basic dep, with just `requires`, `met?` and `meet`, is all you need to describe an end goal. But this generic nature of `met?` and `meet` means just as they're general purpose, they can lack focus. For example, installing an app using the system's package manager has a predictable `met?` block---check whether the package is present and its binaries are in the path.

  A lot of chores are variations on a theme like this, or just too cumbersome to do repeatedly at a low level. So babushka provides a way to write dep templates, or _meta deps_, that can be reused later. These meta deps allow you to focus the DSL, and make it even more concise.

  For example, Babushka ships with a meta dep that knows how to install TextMate bundles, given just the URL. All the actual logic, including the code for `met?` and `meet`, is wrapped up in the meta dep.

:preruby
  meta :tmbundle do
    accepts_value_for :source

    template {
      requires 'TextMate.app'
      def path
        '~/Library/Application Support/TextMate/Bundles' / name
      end
      met? {
        path.dir?
      }
      meet {
        path.parent.mkdir
        git source, :to => path
        shell %Q{osascript -e 'tell app "TextMate" to reload bundles'}
      }
    }
  end

:md
  Notice how the contents of the `template` block looks like a normal dep. That's cause it is---the meta dep is a factory, that accepts a value defined by `accepts_value_for` (in this case, `source`) and produces regular deps at runtime under the covers.

  Given the `tmbundle` meta dep, this dep handles the cucumber bundle:

:preruby
  dep 'Cucumber.tmbundle' do
    source 'https://github.com/bmabey/cucumber-tmbundle.git'
  end

:md
  Notice there's no imperative code there at all---just declarations. That's what the DSL aims for. Instead of saying "do this, then do this, then do this", the code should say "here's a description of the problem, now you work it out." Also notice that there's no TextMate-specific logic. Adding this extra level of abstraction means all that's left are the specifics for _this_ TextMate bundle.
